---
tags:
  - algorithms
date: 2024-10-30
source: "[[COMPSCI 170]]"
---

[[Divide and Conquer Paradigm]] follows a generic pattern, a problem of size $n$ is solved recursively by $a$ subproblems of size $\frac{n}{b}$ and then combining these answers in $O(n^{d})$ time.

The [[Master Theorem]] can be used to solve for running times of most divide and conquer procedures. 

### Example: The Fibonacci Sequence

$$0, 1, 1, 2, 3, 5, 8, 13, 21, 34, . . .$$

 More formally, the Fibonacci numbers $F_n$ are generated by the simple rule:

$$F_{n} = 
\begin{cases} 
      F_{n-1} + F_{n-2}, \text{ if } n> 1 \\ \\
\
      1, \text{ if } n = 1 \\ \\
\
      0, \text{ if } n = 1 \\
   \end{cases}
$$

_Recursive Fibonacci Sequence_ Implementation:

```python
def fib1(n):
    if n == 0:
        return 0
    if n == 1:
        return 1
    return fib1(n - 1) + fib1(n - 2)

```

![[Screenshot 2024-09-19 at 11.00.33 PM.png]]

If $T[n]$ is the number of function calls in execution of F(n),

- How many nodes are in this tree? 
	-  # Nodes (n) = # Nodes (n-1 subtree) + # Nodes (n-2 subtree)

$$T[n] = T[n-1] +T[n-2]+1$$

- Calculate Recurrence Relation, or take a guess: $T[n] =$ exponential in $n$.

This is because there are a lot of repeated nodes. We should __reuse the computation__.

So intuitively the _Iterative Fibonacci Sequence_,

```python
def fib2(n):
    if n == 0:
        return 0
    # Create an array to store Fibonacci numbers
    f = [0] * (n + 1)
    f[0] = 0
    f[1] = 1

    # Loop to calculate Fibonacci numbers
    for i in range(2, n + 1):
        f[i] = f[i - 1] + f[i - 2]

    # Return the nth Fibonacci number
    return f[n]
```

$$T[n] = \text{Time taken to create array} + \text{n} \cdot \text{(addition time)}$$
$$T[n] = O(n \cdot \text{Time for one addition})$$[[Integer Multiplication]] goes into how Time for addition is calculated.
