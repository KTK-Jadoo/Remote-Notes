---
tags:
  - compsci
date: 2024-08-29
source: "[[COMPSCI 170]]"
---
# Definition

$$0, 1, 1, 2, 3, 5, 8, 13, 21, 34, . . . ,$$
 More formally, the Fibonacci numbers $F_n$ are generated by the simple rule:

$$F_{n} = 
\begin{cases} 
      F_{n-1} + F_{n-2}, \text{ if } n> 1 \\ \\
\
      1, \text{ if } n = 1 \\ \\
\
      0, \text{ if } n = 1 \\
   \end{cases}
$$

#### [[Analysis of Algorithms|Algorithms]] for Fibonacci Calculation

###### An Exponential Algorithm

Recursive Implementation 

```python
def fib1(n):
    if n == 0:
        return 0
    if n == 1:
        return 1
    return fib1(n - 1) + fib1(n - 2)

```

[[Recurrence Relations|Recurrence relation]] of $F_n$, we see that $T(n) \ge F_n$ . This is very bad news: the running time of the algorithm grows as fast as the Fibonacci numbers! _T (n) is exponential in n_, which implies that the algorithm is impractically slow except for very small values of n.

The running time of `fib1(n)` is proportional to $2^{0.694n}≈ (1.6)^n$ so it takes 1.6 times longer to compute $F_{n+1}$ than $F_n$. And under Moore’s law, computers get roughly 1.6 times faster each year.


### 2. A Polynomial Algorithm

A more sensible scheme would store the intermediate results— the values _$F_0, F_1, . . . , F_{n−1}$_ — as soon as they become known.

```pcode
function fib2(n) 
if n = 0 return 0 
create an array f[0 . . . n] 
f[0] = 0, f[1] = 1 
for i = 2 . . . n: 
	f[i] = f[i − 1] + f[i − 2] 
return f[n]
```


(echo; echo 'eval "$(/opt/homebrew/bin/brew shellenv)"') >> /Users/jadoo/.zprofile

    eval "$(/opt/homebrew/bin/brew shellenv)"