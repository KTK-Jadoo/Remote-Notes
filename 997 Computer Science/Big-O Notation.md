---
tags:
  - "#algorithms"
  - math
date: 2024-05-29
source: "[[COMPSCI 170]]"
---
# Definition

A way to approximately measure the runtime of an algorithm. 

Let $T[n]$ be the time taken by an algorithm on an input $n$.
- Depends on computer, processor, language etc


### $O$ Notation

>[!note] Formal Definition of Big-O Notation
>Let $f:\mathbb{N}\rightarrow\mathbb{N}$ and $g:\mathbb{N}\rightarrow\mathbb{N}$
>We say that $f = O(g) \iff$ f grows no faster than g $\iff$ f is almost $C \cdot g$ so, $\exists$ constant $C$ s.t $$f(n) \le C \cdot g(n)$$

Observations on common functions:
- $poly(n) = O(n^{degree})$
- $n^{3}=O(n^{4}) \iff \space n^{3} \text{ grows no faster than } n^{4}$
- Any polynomial in n $= O(2^{n})$
- $\log(n) = O(\text{any polynomial in n})$


### $\Theta$ Notation

>[!note] Formal Definition of $\Theta$ Notation
>We say $f=\Theta(g)$ ,
>if $f=O(g)$ AND $g=O(f) \iff f\approx g$


### $\Omega$ Notation

>[!note] Formal Definition of $\Omega$ Notation
>We say $f=\Omega(g) \iff f = O(g)$ 


### Example: The Fibonacci Sequence

$$0, 1, 1, 2, 3, 5, 8, 13, 21, 34, . . . ,$$

 More formally, the Fibonacci numbers $F_n$ are generated by the simple rule:

$$F_{n} = 
\begin{cases} 
      F_{n-1} + F_{n-2}, \text{ if } n> 1 \\ \\
\
      1, \text{ if } n = 1 \\ \\
\
      0, \text{ if } n = 1 \\
   \end{cases}
$$

_Recursive Fibonacci Sequence_ Implementation:

```python
def fib1(n):
    if n == 0:
        return 0
    if n == 1:
        return 1
    return fib1(n - 1) + fib1(n - 2)

```

![[Screenshot 2024-09-19 at 11.00.33 PM.png]]

If $T[n]$ is the number of function calls in execution of F(n),

- How many nodes are in this tree? 
	-  # Nodes (n) = # Nodes (n-1 subtree) + # Nodes (n-2 subtree)

$$T[n] = T[n-1] +T[n-2]+1$$

- Calculate [[Recurrence Relations]], or take a guess: $T[n] =$ exponential in $n$.

This is because there are a lot of repeated nodes. We should __reuse the computation__.

So intuitively the _Iterative Fibonacci Sequence_,

```python
def fib2(n):
    if n == 0:
        return 0
    # Create an array to store Fibonacci numbers
    f = [0] * (n + 1)
    f[0] = 0
    f[1] = 1

    # Loop to calculate Fibonacci numbers
    for i in range(2, n + 1):
        f[i] = f[i - 1] + f[i - 2]

    # Return the nth Fibonacci number
    return f[n]
```

$$T[n] = \text{Time taken to create array} + \text{n} \cdot \text{(addition time)}$$
$$T[n] = O(n \cdot \text{Time for one addition})$$[[Integer Multiplication]] goes into how Time for addition is calculated.

### Calculating Runtime

__Discussion 1__:
 
 (a) $$
 L'hopital's \space Rule \rightarrow \frac{6}{24}
 \rightarrow \space < \infty, \therefore n^{3}=O(n^4)

$$
(b) 
$$
f(n) = n
, \space
g(n) = 2n
$$
$$f(n)=\Theta(g(n))\implies f(n) = O(g(n))$$


(c)

Q2

(b)
(i)$$
Limit = \frac{3}{4}\therefore f(n)=\Theta(g(n))$$
Differ by constant multiple.

(ii)$$\lim_{n \rightarrow \infty}\frac{nlog(n^4)}{n^{2}log(n^{3)}}$$
$$\lim_{n \rightarrow \infty}\frac{4nlog(n)}{3n^{2}log(n}$$



So limit is 0

(iii) $$
L'Hopital's Rule \space,
f(n) = \Omega(g(n))
$$
(iv)
$$f(n) = \Theta (g(n))$$

Q3 

Runtime of recursive functions:

- Standard $T(n) = aT\left(\frac{n}{b}\right)+ \theta[n^d]$
- a = # of subproblems
- b = relative input size
- Last term = processing time


