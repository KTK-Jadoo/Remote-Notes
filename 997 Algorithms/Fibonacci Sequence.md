---
tags:
  - compsci
date: 2024-12-12
source: "[[COMPSCI 170]]"
---
# Fibonacci Sequence

From [[Al Khwarizmi]], further developed and propagandized by 15th century mathematician [[Leonardo Fibonnaci]], 

$$0, 1, 1, 2, 3, 5, 8, 13, 21, 34, . . .$$

 More formally, the Fibonacci numbers $F_n$ are generated by the simple rule:

$$F_{n} = 
\begin{cases} 
      F_{n-1} + F_{n-2}, \text{ if } n> 1 \\ \\
\
      1, \text{ if } n = 1 \\ \\
\
      0, \text{ if } n = 0 \\
   \end{cases}
$$

## Exponential Fibonacci:

```python
def fib1(n):
    if n == 0:
        return 0
    if n == 1:
        return 1
    return fib1(n - 1) + fib1(n - 2)

```

![[Screenshot 2024-09-19 at 11.00.33 PM.png]]

If $T[n]$ is the number of function calls in execution of F(n),

- How many nodes are in this tree? 
	-  # Nodes (n) = # Nodes (n-1 subtree) + # Nodes (n-2 subtree)

$$T[n] = T[n-1] +T[n-2]+1$$
We can see that $T(n)\ge F_{n }$

This is because there are a lot of repeated nodes. We should __reuse the computation__.

Also, $F_{150} \text{ is } \gg 580$ bits, so we can't use 64 bit Integers.
We need to use [[Big Integer]] data type.

## Polynomial Fibonacci Sequence:

```python
def fib2(n):
    if n == 0:
        return 0
    # Create an array to store Fibonacci numbers
    f = [0] * (n + 1)
    f[0] = 0
    f[1] = 1

    # Loop to calculate Fibonacci numbers
    for i in range(2, n + 1):
        f[i] = f[i - 1] + f[i - 2]

    # Return the nth Fibonacci number
    return f[n]
```

$$T[n] = \text{Time taken to create array} + \text{n} \cdot \text{(addition time)}$$
So $T(n)$ depends on the [[Integer Operations#Integer Addition]] 
